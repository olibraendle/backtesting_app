package com.backtester.ui.panels;

import com.backtester.core.engine.BacktestConfig;
import com.backtester.core.engine.BacktestResult;
import com.backtester.core.engine.SimpleBacktestEngine;
import com.backtester.core.portfolio.Portfolio;
import com.backtester.stats.BacktestStatistics;
import com.backtester.stats.MonteCarloSimulator;
import com.backtester.stats.SensitivityAnalyzer;
import com.backtester.stats.StatisticsCalculator;
import com.backtester.stats.StressTester;
import com.backtester.strategy.StrategyParameter;
import com.backtester.ui.charts.HeatmapChart;
import com.backtester.strategy.BaseStrategy;
import com.backtester.strategy.StrategyRegistry;
import com.backtester.common.model.TimeSeries;
import javafx.application.Platform;
import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.chart.LineChart;
import javafx.scene.chart.NumberAxis;
import javafx.scene.chart.XYChart;
import javafx.scene.control.*;
import javafx.scene.layout.*;

import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

/**
 * Panel 1: Benchmarks and Statistics display.
 * Shows equity curve, statistics table, and Monte Carlo results.
 */
public class BenchmarkPanel {

    private final VBox root;
    private final TabPane tabPane;
    private final LineChart<Number, Number> equityChart;
    private final TableView<StatRow> statsTable;
    private final VBox monteCarloBox;
    private final LineChart<Number, Number> mcEquityCurvesChart;
    private final TextArea monteCarloText;
    private final TextArea walkForwardText;
    private final LineChart<Number, Number> wfEquityChart;
    private final HeatmapChart heatmapChart;
    private final ComboBox<String> heatmapParam1Combo;
    private final ComboBox<String> heatmapParam2Combo;
    private final ComboBox<String> heatmapMetricCombo;
    private final Button runHeatmapButton;
    private final TextArea heatmapResultText;
    private final TextArea stressTestText;
    private final TableView<StressRow> stressTestTable;
    private final Button runStressTestButton;

    // Out-of-Sample testing components
    private final Slider oosSlider;
    private final Label oosLabel;
    private final Button runOosTestButton;
    private final LineChart<Number, Number> oosEquityChart;
    private final TextArea oosResultText;
    private final TableView<OosRow> oosTable;

    // Stored context for running analyses
    private BacktestResult lastResult;
    private BacktestConfig lastConfig;
    private BaseStrategy lastStrategy;
    private TimeSeries lastData;

    public BenchmarkPanel() {
        root = new VBox(10);
        root.setPadding(new Insets(10));

        tabPane = new TabPane();
        tabPane.setTabClosingPolicy(TabPane.TabClosingPolicy.UNAVAILABLE);

        // Tab 1: Equity Curve
        equityChart = createEquityChart();
        Tab chartTab = new Tab("Equity Curve", equityChart);

        // Tab 2: Statistics
        statsTable = createStatsTable();
        Tab statsTab = new Tab("Statistics", new ScrollPane(statsTable));

        // Tab 3: Monte Carlo with equity curves visualization
        monteCarloBox = new VBox(10);
        monteCarloBox.setPadding(new Insets(5));

        // Create equity curves chart for Monte Carlo
        mcEquityCurvesChart = createEquityChart();
        mcEquityCurvesChart.setTitle("Monte Carlo Equity Curves (100 Simulations)");
        mcEquityCurvesChart.setLegendVisible(false);
        mcEquityCurvesChart.setCreateSymbols(false);

        // Text summary
        monteCarloText = new TextArea();
        monteCarloText.setEditable(false);
        monteCarloText.setStyle("-fx-font-family: monospace;");
        monteCarloText.setPrefHeight(180);

        monteCarloBox.getChildren().addAll(mcEquityCurvesChart, monteCarloText);
        VBox.setVgrow(mcEquityCurvesChart, Priority.ALWAYS);

        Tab mcTab = new Tab("Monte Carlo", new ScrollPane(monteCarloBox));

        // Tab 4: Walk-Forward Analysis
        VBox wfBox = new VBox(10);
        wfBox.setPadding(new Insets(5));

        wfEquityChart = createEquityChart();
        wfEquityChart.setTitle("Shuffled Trade Sequences (Overfitting Detection)");
        wfEquityChart.setLegendVisible(false);

        walkForwardText = new TextArea();
        walkForwardText.setEditable(false);
        walkForwardText.setStyle("-fx-font-family: monospace;");
        walkForwardText.setPrefHeight(150);
        walkForwardText.setText("WALK-FORWARD / OVERFITTING ANALYSIS\n" +
                "====================================\n\n" +
                "This tab shows the original equity curve compared to curves\n" +
                "generated by shuffling the trade order. If the original curve\n" +
                "is significantly better than shuffled versions, the strategy\n" +
                "may be overfit to the specific sequence of historical data.\n\n" +
                "Run a backtest first to see the analysis.");

        wfBox.getChildren().addAll(wfEquityChart, walkForwardText);
        VBox.setVgrow(wfEquityChart, Priority.ALWAYS);

        Tab wfTab = new Tab("Walk-Forward", new ScrollPane(wfBox));

        // Tab 5: Parameter Sensitivity Heatmap
        heatmapChart = new HeatmapChart();
        VBox heatmapBox = new VBox(10);
        heatmapBox.setPadding(new Insets(10));

        // Controls for heatmap
        Label param1Label = new Label("X-Axis Parameter:");
        heatmapParam1Combo = new ComboBox<>();
        heatmapParam1Combo.setPrefWidth(150);

        Label param2Label = new Label("Y-Axis Parameter:");
        heatmapParam2Combo = new ComboBox<>();
        heatmapParam2Combo.setPrefWidth(150);

        Label metricLabel = new Label("Metric:");
        heatmapMetricCombo = new ComboBox<>();
        heatmapMetricCombo.getItems().addAll(
                "Net Return %", "Sharpe Ratio", "Sortino Ratio", "Profit Factor",
                "Max Drawdown %", "Win Rate %", "Calmar Ratio", "Expectancy"
        );
        heatmapMetricCombo.setValue("Sharpe Ratio");
        heatmapMetricCombo.setPrefWidth(150);

        runHeatmapButton = new Button("Run Sensitivity Analysis");
        runHeatmapButton.setStyle("-fx-font-weight: bold;");
        runHeatmapButton.setDisable(true);
        runHeatmapButton.setOnAction(e -> runHeatmapAnalysis());

        HBox heatmapControlBox = new HBox(10,
                param1Label, heatmapParam1Combo,
                param2Label, heatmapParam2Combo,
                metricLabel, heatmapMetricCombo,
                runHeatmapButton
        );
        heatmapControlBox.setPadding(new Insets(5));

        heatmapResultText = new TextArea();
        heatmapResultText.setEditable(false);
        heatmapResultText.setStyle("-fx-font-family: monospace;");
        heatmapResultText.setPrefHeight(120);
        heatmapResultText.setText("PARAMETER SENSITIVITY ANALYSIS\n" +
                "==============================\n\n" +
                "This analysis tests strategy performance across parameter combinations\n" +
                "to identify optimal parameter regions and detect potential overfitting.\n\n" +
                "HOW TO USE:\n" +
                "1. Select two parameters to analyze (X-axis and Y-axis)\n" +
                "2. Choose a performance metric to optimize\n" +
                "3. Click 'Run Sensitivity Analysis'\n\n" +
                "INTERPRETATION:\n" +
                "- Large green plateaus indicate robust parameter regions\n" +
                "- Isolated peaks suggest overfitting risk\n" +
                "- Smooth gradients indicate stable parameter behavior");

        heatmapBox.getChildren().addAll(heatmapControlBox, heatmapChart.getNode(), heatmapResultText);
        VBox.setVgrow(heatmapChart.getNode(), Priority.ALWAYS);

        Tab heatmapTab = new Tab("Heatmap", new ScrollPane(heatmapBox));

        // Tab 6: Stress Testing
        VBox stressBox = new VBox(10);
        stressBox.setPadding(new Insets(5));

        // Run stress test button
        runStressTestButton = new Button("Run Stress Test");
        runStressTestButton.setStyle("-fx-font-weight: bold;");
        runStressTestButton.setDisable(true);
        runStressTestButton.setOnAction(e -> runStressTest());

        HBox buttonBox = new HBox(10, runStressTestButton);
        buttonBox.setPadding(new Insets(5));

        stressTestTable = createStressTestTable();
        stressTestText = new TextArea();
        stressTestText.setEditable(false);
        stressTestText.setStyle("-fx-font-family: monospace;");
        stressTestText.setPrefHeight(100);
        stressTestText.setText("STRESS TESTING\n" +
                "==============\n\n" +
                "Click 'Run Stress Test' to evaluate strategy robustness under:\n" +
                "- Higher transaction costs (2x, 3x commissions/slippage/spread)\n" +
                "- Increased volatility (1.5x, 2x)\n" +
                "- Market crashes (10%, 20%, 30%)\n" +
                "- Gap events and trend reversals\n\n" +
                "Run a backtest first, then click the button above.");

        stressBox.getChildren().addAll(buttonBox, stressTestTable, stressTestText);
        VBox.setVgrow(stressTestTable, Priority.ALWAYS);

        Tab stressTab = new Tab("Stress Test", new ScrollPane(stressBox));

        // Tab 7: Out-of-Sample Testing
        VBox oosBox = new VBox(10);
        oosBox.setPadding(new Insets(10));

        // OOS percentage slider
        oosLabel = new Label("Out-of-Sample Reserve: 20%");
        oosLabel.setStyle("-fx-font-weight: bold;");

        oosSlider = new Slider(10, 50, 20);
        oosSlider.setShowTickLabels(true);
        oosSlider.setShowTickMarks(true);
        oosSlider.setMajorTickUnit(10);
        oosSlider.setMinorTickCount(4);
        oosSlider.setBlockIncrement(5);
        oosSlider.valueProperty().addListener((obs, oldVal, newVal) -> {
            oosLabel.setText(String.format("Out-of-Sample Reserve: %.0f%%", newVal.doubleValue()));
        });

        runOosTestButton = new Button("Run Out-of-Sample Test");
        runOosTestButton.setStyle("-fx-font-weight: bold;");
        runOosTestButton.setDisable(true);
        runOosTestButton.setOnAction(e -> runOutOfSampleTest());

        HBox oosControlBox = new HBox(15, oosLabel, oosSlider, runOosTestButton);
        oosControlBox.setPadding(new Insets(5));

        // OOS equity chart comparing IS and OOS performance
        oosEquityChart = createEquityChart();
        oosEquityChart.setTitle("In-Sample vs Out-of-Sample Performance");

        // OOS results table
        oosTable = createOosTable();

        // OOS text summary
        oosResultText = new TextArea();
        oosResultText.setEditable(false);
        oosResultText.setStyle("-fx-font-family: monospace;");
        oosResultText.setPrefHeight(150);
        oosResultText.setText("OUT-OF-SAMPLE TESTING\n" +
                "=====================\n\n" +
                "Out-of-Sample (OOS) testing reserves a portion of data that the strategy\n" +
                "has never seen during optimization. This helps detect overfitting.\n\n" +
                "HOW IT WORKS:\n" +
                "1. Data is split: first X% for In-Sample (training), last Y% for Out-of-Sample\n" +
                "2. Strategy is tested on both portions separately\n" +
                "3. Results are compared - large performance gaps indicate overfitting\n\n" +
                "INTERPRETATION:\n" +
                "- OOS return > 70% of IS return: Strategy likely robust\n" +
                "- OOS return 50-70% of IS return: Moderate overfitting risk\n" +
                "- OOS return < 50% of IS return: High overfitting risk\n\n" +
                "Select reserve percentage and click 'Run Out-of-Sample Test'.");

        oosBox.getChildren().addAll(oosControlBox, oosEquityChart, oosTable, oosResultText);
        VBox.setVgrow(oosEquityChart, Priority.ALWAYS);

        Tab oosTab = new Tab("Out-of-Sample", new ScrollPane(oosBox));

        tabPane.getTabs().addAll(chartTab, statsTab, mcTab, wfTab, heatmapTab, stressTab, oosTab);
        VBox.setVgrow(tabPane, Priority.ALWAYS);

        root.getChildren().add(tabPane);
    }

    private TableView<StressRow> createStressTestTable() {
        TableView<StressRow> table = new TableView<>();

        TableColumn<StressRow, String> scenarioCol = new TableColumn<>("Scenario");
        scenarioCol.setCellValueFactory(data -> data.getValue().scenarioProperty());
        scenarioCol.setPrefWidth(180);

        TableColumn<StressRow, String> returnCol = new TableColumn<>("Return");
        returnCol.setCellValueFactory(data -> data.getValue().returnProperty());
        returnCol.setPrefWidth(80);

        TableColumn<StressRow, String> sharpeCol = new TableColumn<>("Sharpe");
        sharpeCol.setCellValueFactory(data -> data.getValue().sharpeProperty());
        sharpeCol.setPrefWidth(70);

        TableColumn<StressRow, String> ddCol = new TableColumn<>("Max DD");
        ddCol.setCellValueFactory(data -> data.getValue().maxDDProperty());
        ddCol.setPrefWidth(80);

        TableColumn<StressRow, String> statusCol = new TableColumn<>("Status");
        statusCol.setCellValueFactory(data -> data.getValue().statusProperty());
        statusCol.setPrefWidth(80);
        statusCol.setCellFactory(col -> new TableCell<>() {
            @Override
            protected void updateItem(String item, boolean empty) {
                super.updateItem(item, empty);
                if (empty || item == null) {
                    setText(null);
                    setStyle("");
                } else {
                    setText(item);
                    switch (item) {
                        case "PASS" -> setStyle("-fx-text-fill: #00cc00;");
                        case "MARGINAL" -> setStyle("-fx-text-fill: #cccc00;");
                        case "FAIL", "FAILED" -> setStyle("-fx-text-fill: #cc0000;");
                        default -> setStyle("");
                    }
                }
            }
        });

        table.getColumns().addAll(scenarioCol, returnCol, sharpeCol, ddCol, statusCol);
        table.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);

        return table;
    }

    private LineChart<Number, Number> createEquityChart() {
        NumberAxis xAxis = new NumberAxis();
        xAxis.setLabel("Bar");
        xAxis.setAutoRanging(true);

        NumberAxis yAxis = new NumberAxis();
        yAxis.setLabel("Equity ($)");
        yAxis.setAutoRanging(true);

        LineChart<Number, Number> chart = new LineChart<>(xAxis, yAxis);
        chart.setCreateSymbols(false);
        chart.setAnimated(false);
        chart.setLegendVisible(true);

        return chart;
    }

    private TableView<StatRow> createStatsTable() {
        TableView<StatRow> table = new TableView<>();

        TableColumn<StatRow, String> categoryCol = new TableColumn<>("Category");
        categoryCol.setCellValueFactory(data -> data.getValue().categoryProperty());
        categoryCol.setPrefWidth(120);

        TableColumn<StatRow, String> metricCol = new TableColumn<>("Metric");
        metricCol.setCellValueFactory(data -> data.getValue().metricProperty());
        metricCol.setPrefWidth(180);

        TableColumn<StatRow, String> valueCol = new TableColumn<>("Value");
        valueCol.setCellValueFactory(data -> data.getValue().valueProperty());
        valueCol.setPrefWidth(150);

        table.getColumns().addAll(categoryCol, metricCol, valueCol);
        table.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);

        return table;
    }

    public Node getNode() {
        return root;
    }

    /**
     * Set context for running stress tests.
     */
    public void setContext(BacktestConfig config, BaseStrategy strategy, TimeSeries data) {
        this.lastConfig = config;
        this.lastStrategy = strategy;
        this.lastData = data;
        runStressTestButton.setDisable(strategy == null || data == null);
        runOosTestButton.setDisable(strategy == null || data == null);

        // Populate heatmap parameter combos
        heatmapParam1Combo.getItems().clear();
        heatmapParam2Combo.getItems().clear();

        if (strategy != null) {
            List<StrategyParameter> params = strategy.getParameters();
            // Only include numeric parameters
            for (StrategyParameter param : params) {
                if (param.type() == StrategyParameter.ParameterType.INTEGER ||
                    param.type() == StrategyParameter.ParameterType.DOUBLE) {
                    heatmapParam1Combo.getItems().add(param.name());
                    heatmapParam2Combo.getItems().add(param.name());
                }
            }

            // Set default selections if we have at least 2 parameters
            if (heatmapParam1Combo.getItems().size() >= 2) {
                heatmapParam1Combo.setValue(heatmapParam1Combo.getItems().get(0));
                heatmapParam2Combo.setValue(heatmapParam2Combo.getItems().get(1));
                runHeatmapButton.setDisable(false);
            } else if (heatmapParam1Combo.getItems().size() == 1) {
                heatmapParam1Combo.setValue(heatmapParam1Combo.getItems().get(0));
                runHeatmapButton.setDisable(true);
            } else {
                runHeatmapButton.setDisable(true);
            }
        } else {
            runHeatmapButton.setDisable(true);
        }
    }

    /**
     * Update panel with backtest results.
     */
    public void setResult(BacktestResult result, BacktestStatistics stats,
                          MonteCarloSimulator.MonteCarloResult mcResult) {
        this.lastResult = result;
        updateEquityChart(result);
        updateStatsTable(stats, result);
        updateMonteCarloChart(mcResult);
        updateWalkForwardChart(mcResult);
    }

    private void updateEquityChart(BacktestResult result) {
        equityChart.getData().clear();

        // Strategy equity curve
        XYChart.Series<Number, Number> strategySeries = new XYChart.Series<>();
        strategySeries.setName("Strategy");

        List<Portfolio.EquityPoint> history = result.getEquityHistory();
        int step = Math.max(1, history.size() / 500); // Limit points for performance

        for (int i = 0; i < history.size(); i += step) {
            strategySeries.getData().add(new XYChart.Data<>(i, history.get(i).equity()));
        }

        // Buy & Hold curve - use actual equity history
        XYChart.Series<Number, Number> buyHoldSeries = new XYChart.Series<>();
        buyHoldSeries.setName("Buy & Hold");

        List<Double> bhHistory = result.getBuyAndHoldEquityHistory();
        if (!bhHistory.isEmpty()) {
            int bhStep = Math.max(1, bhHistory.size() / 500);
            for (int i = 0; i < bhHistory.size(); i += bhStep) {
                buyHoldSeries.getData().add(new XYChart.Data<>(i, bhHistory.get(i)));
            }
        }

        equityChart.getData().addAll(strategySeries, buyHoldSeries);

        // Apply consistent colors - Strategy=blue, Buy&Hold=gray
        // This ensures legend symbols match the line colors
        Platform.runLater(() -> {
            if (strategySeries.getNode() != null) {
                strategySeries.getNode().setStyle("-fx-stroke: #2196F3; -fx-stroke-width: 2;");
            }
            if (buyHoldSeries.getNode() != null) {
                buyHoldSeries.getNode().setStyle("-fx-stroke: #9E9E9E; -fx-stroke-width: 1.5;");
            }
            // Style legend symbols to match line colors
            styleChartLegend(equityChart, "#2196F3", "#9E9E9E");
        });
    }

    /**
     * Style chart legend symbols to match line colors.
     */
    private void styleChartLegend(LineChart<Number, Number> chart, String... colors) {
        for (Node legend : chart.lookupAll(".chart-legend-item-symbol")) {
            // Find which series this legend item belongs to by checking sibling text
            Node parent = legend.getParent();
            if (parent != null) {
                int index = 0;
                for (Node sibling : parent.getParent().getChildrenUnmodifiable()) {
                    if (sibling == parent) break;
                    index++;
                }
                if (index < colors.length) {
                    legend.setStyle("-fx-background-color: " + colors[index] + ";");
                }
            }
        }
    }

    private void updateStatsTable(BacktestStatistics stats, BacktestResult result) {
        statsTable.getItems().clear();

        // P&L Metrics
        addStat("P&L", "Net Profit", formatCurrency(stats.netProfit()));
        addStat("P&L", "Net Return", formatPercent(stats.netReturnPercent()));
        addStat("P&L", "Gross Profit", formatCurrency(stats.grossProfit()));
        addStat("P&L", "Gross Loss", formatCurrency(stats.grossLoss()));
        addStat("P&L", "Profit Factor", formatNumber(stats.profitFactor()));
        addStat("P&L", "Max Equity Run-up", formatPercent(stats.maxEquityRunUpPercent()));

        // Risk Metrics
        addStat("Risk", "Max Drawdown", formatCurrency(stats.maxDrawdown()));
        addStat("Risk", "Max Drawdown %", formatPercent(stats.maxDrawdownPercent()));
        addStat("Risk", "Buy & Hold Return", formatPercent(stats.buyAndHoldReturn()));
        addStat("Risk", "Alpha", formatPercent(stats.alpha()));
        addStat("Risk", "Sharpe Ratio", formatNumber(stats.sharpeRatio()));
        addStat("Risk", "Sortino Ratio", formatNumber(stats.sortinoRatio()));
        addStat("Risk", "Calmar Ratio", formatNumber(stats.calmarRatio()));
        addStat("Risk", "Recovery Factor", formatNumber(stats.recoveryFactor()));

        // Trade Metrics
        addStat("Trades", "Total Trades", String.valueOf(stats.totalTrades()));
        addStat("Trades", "Winning Trades", String.valueOf(stats.winningTrades()));
        addStat("Trades", "Losing Trades", String.valueOf(stats.losingTrades()));
        addStat("Trades", "Win Rate", formatPercent(stats.winRate()));
        addStat("Trades", "Avg Trade", formatCurrency(stats.avgTrade()));
        addStat("Trades", "Avg Win", formatCurrency(stats.avgWin()));
        addStat("Trades", "Avg Loss", formatCurrency(stats.avgLoss()));
        addStat("Trades", "Payoff Ratio", formatNumber(stats.payoffRatio()));
        addStat("Trades", "Expectancy", formatCurrency(stats.expectancy()));
        addStat("Trades", "Largest Win", formatCurrency(stats.largestWin()));
        addStat("Trades", "Largest Loss", formatCurrency(stats.largestLoss()));
        addStat("Trades", "Avg Bars in Trade", formatNumber(stats.avgBarsInTrade()));
        addStat("Trades", "Max Consecutive Wins", String.valueOf(stats.maxConsecutiveWins()));
        addStat("Trades", "Max Consecutive Losses", String.valueOf(stats.maxConsecutiveLosses()));

        // Volatility
        addStat("Volatility", "Return Volatility", formatPercent(stats.returnVolatility()));
        addStat("Volatility", "Downside Deviation", formatPercent(stats.downsideDeviation()));
        addStat("Volatility", "Time in Market", formatPercent(stats.timeInMarket()));

        // Costs
        addStat("Costs", "Total Commissions", formatCurrency(stats.totalCommissions()));
        addStat("Costs", "Total Slippage", formatCurrency(stats.totalSlippage()));
        addStat("Costs", "Total Costs", formatCurrency(stats.totalCosts()));
        addStat("Costs", "Cost Impact", formatPercent(stats.costImpactPercent()));
    }

    private void addStat(String category, String metric, String value) {
        statsTable.getItems().add(new StatRow(category, metric, value));
    }

    private void updateMonteCarloChart(MonteCarloSimulator.MonteCarloResult mc) {
        // Update equity curves chart
        mcEquityCurvesChart.getData().clear();

        List<double[]> curves = mc.equityCurves();
        if (curves != null && !curves.isEmpty()) {
            // Add each equity curve as a separate series
            for (int c = 0; c < curves.size(); c++) {
                double[] curve = curves.get(c);
                XYChart.Series<Number, Number> series = new XYChart.Series<>();

                // Sample points to avoid too many data points
                int step = Math.max(1, curve.length / 100);
                for (int i = 0; i < curve.length; i += step) {
                    series.getData().add(new XYChart.Data<>(i, curve[i]));
                }
                // Always include last point
                if ((curve.length - 1) % step != 0) {
                    series.getData().add(new XYChart.Data<>(curve.length - 1, curve[curve.length - 1]));
                }

                mcEquityCurvesChart.getData().add(series);
            }

            // Style the curves with varying colors and transparency
            for (int i = 0; i < mcEquityCurvesChart.getData().size(); i++) {
                XYChart.Series<Number, Number> series = mcEquityCurvesChart.getData().get(i);
                if (series.getNode() != null) {
                    // Random color with transparency
                    String color = getRandomColor(i);
                    series.getNode().setStyle("-fx-stroke: " + color + "; -fx-stroke-width: 1;");
                }
            }
        }

        // Update text summary
        StringBuilder sb = new StringBuilder();
        sb.append("MONTE CARLO ANALYSIS\n");
        sb.append("====================\n\n");
        sb.append(String.format("Simulations: %,d  |  Curves displayed: %d\n\n",
                mc.numSimulations(), curves != null ? curves.size() : 0));

        sb.append("FINAL EQUITY: 5th=$%,.0f | 50th=$%,.0f | 95th=$%,.0f | Mean=$%,.0f\n".formatted(
                mc.equity5thPercentile(), mc.equity50thPercentile(),
                mc.equity95thPercentile(), mc.equityMean()));
        sb.append("MAX DRAWDOWN: 5th=%.1f%% | 50th=%.1f%% | 95th=%.1f%% | Mean=%.1f%%\n".formatted(
                mc.maxDD5thPercentile(), mc.maxDD50thPercentile(),
                mc.maxDD95thPercentile(), mc.maxDDMean()));
        sb.append(String.format("RUIN PROBABILITY (50%% loss): %.2f%%\n", mc.ruinProbability()));
        sb.append(String.format("Expected Return Range: %s  |  Drawdown Range: %s",
                mc.getReturnRange(), mc.getDrawdownRange()));

        monteCarloText.setText(sb.toString());
    }

    private void updateWalkForwardChart(MonteCarloSimulator.MonteCarloResult mc) {
        // Use Monte Carlo curves for walk-forward/overfitting analysis
        wfEquityChart.getData().clear();

        List<double[]> curves = mc.equityCurves();
        if (curves == null || curves.isEmpty()) return;

        // Add shuffled equity curves
        int numToShow = Math.min(50, curves.size());
        for (int c = 0; c < numToShow; c++) {
            double[] curve = curves.get(c);
            XYChart.Series<Number, Number> series = new XYChart.Series<>();

            int step = Math.max(1, curve.length / 100);
            for (int i = 0; i < curve.length; i += step) {
                series.getData().add(new XYChart.Data<>(i, curve[i]));
            }
            wfEquityChart.getData().add(series);
        }

        // Calculate statistics for overfitting analysis
        double[] finalEquities = mc.finalEquities();
        double mean = mc.equityMean();
        double stdDev = mc.equityStdDev();
        double original = lastResult != null ? lastResult.getFinalEquity() : mean;
        double percentile = calculatePercentile(finalEquities, original);

        StringBuilder sb = new StringBuilder();
        sb.append("OVERFITTING ANALYSIS\n");
        sb.append("====================\n\n");
        sb.append(String.format("Original Strategy Final Equity: $%,.2f\n", original));
        sb.append(String.format("Shuffled Mean Final Equity: $%,.2f\n", mean));
        sb.append(String.format("Shuffled Std Dev: $%,.2f\n", stdDev));
        sb.append(String.format("Original vs Shuffled Percentile: %.1f%%\n\n", percentile));

        if (percentile > 90) {
            sb.append("⚠ WARNING: Strategy performs in top 10% of shuffled sequences.\n");
            sb.append("This may indicate overfitting to the specific order of historical trades.\n");
        } else if (percentile > 75) {
            sb.append("CAUTION: Strategy performs better than 75% of shuffled sequences.\n");
            sb.append("Consider additional validation to rule out overfitting.\n");
        } else {
            sb.append("✓ Strategy performance is within normal range of shuffled sequences.\n");
            sb.append("Results appear robust to trade ordering.\n");
        }

        walkForwardText.setText(sb.toString());
    }

    private double calculatePercentile(double[] sortedValues, double value) {
        if (sortedValues == null || sortedValues.length == 0) return 50;
        int count = 0;
        for (double v : sortedValues) {
            if (v < value) count++;
        }
        return (count * 100.0) / sortedValues.length;
    }

    private String getRandomColor(int index) {
        // Generate varied colors for the curves
        String[] colors = {
            "rgba(255,0,0,0.3)", "rgba(0,255,0,0.3)", "rgba(0,0,255,0.3)",
            "rgba(255,255,0,0.3)", "rgba(255,0,255,0.3)", "rgba(0,255,255,0.3)",
            "rgba(255,128,0,0.3)", "rgba(128,0,255,0.3)", "rgba(0,128,255,0.3)",
            "rgba(255,0,128,0.3)", "rgba(128,255,0,0.3)", "rgba(0,255,128,0.3)"
        };
        return colors[index % colors.length];
    }

    private void runStressTest() {
        if (lastStrategy == null || lastData == null || lastConfig == null) {
            stressTestText.setText("ERROR: No strategy or data available.\nRun a backtest first.");
            return;
        }

        runStressTestButton.setDisable(true);
        stressTestText.setText("Running stress tests... please wait.");
        stressTestTable.getItems().clear();

        CompletableFuture.runAsync(() -> {
            try {
                StressTester tester = new StressTester(lastConfig);
                StressTester.StressTestReport report = tester.runAllTests(lastStrategy, lastData);
                tester.shutdown();

                Platform.runLater(() -> {
                    // Populate table
                    for (Map.Entry<String, StressTester.ScenarioResult> entry : report.scenarios().entrySet()) {
                        StressTester.ScenarioResult r = entry.getValue();
                        stressTestTable.getItems().add(new StressRow(
                                entry.getKey(),
                                String.format("%.1f%%", r.netReturn()),
                                String.format("%.2f", r.sharpeRatio()),
                                String.format("%.1f%%", r.maxDrawdown()),
                                r.getStatus()
                        ));
                    }

                    // Update summary
                    StringBuilder sb = new StringBuilder();
                    sb.append("STRESS TEST SUMMARY\n");
                    sb.append("===================\n\n");
                    sb.append(String.format("Robustness Rating: %s\n", report.getRobustnessRating()));
                    sb.append(String.format("Scenarios Passed: %d / %d\n", report.getPassCount(), report.scenarios().size()));
                    sb.append(String.format("Average Return: %.2f%%\n", report.getAverageReturn()));
                    sb.append(String.format("Worst Case Return: %.2f%%\n", report.getWorstReturn()));

                    stressTestText.setText(sb.toString());
                    runStressTestButton.setDisable(false);
                });
            } catch (Exception e) {
                Platform.runLater(() -> {
                    stressTestText.setText("ERROR running stress test: " + e.getMessage());
                    runStressTestButton.setDisable(false);
                });
            }
        });
    }

    private void runHeatmapAnalysis() {
        if (lastStrategy == null || lastData == null || lastConfig == null) {
            heatmapResultText.setText("ERROR: No strategy or data available.\nRun a backtest first.");
            return;
        }

        String param1 = heatmapParam1Combo.getValue();
        String param2 = heatmapParam2Combo.getValue();
        String metricName = heatmapMetricCombo.getValue();

        if (param1 == null || param2 == null || param1.equals(param2)) {
            heatmapResultText.setText("ERROR: Please select two different parameters.");
            return;
        }

        runHeatmapButton.setDisable(true);
        heatmapResultText.setText("Running sensitivity analysis... please wait.\n\n" +
                "Testing " + param1 + " vs " + param2 + " for " + metricName + "...\n" +
                "This may take a minute depending on strategy complexity.");

        CompletableFuture.runAsync(() -> {
            try {
                // Convert metric name to enum
                SensitivityAnalyzer.Metric metric = switch (metricName) {
                    case "Net Return %" -> SensitivityAnalyzer.Metric.NET_RETURN;
                    case "Sharpe Ratio" -> SensitivityAnalyzer.Metric.SHARPE_RATIO;
                    case "Sortino Ratio" -> SensitivityAnalyzer.Metric.SORTINO_RATIO;
                    case "Profit Factor" -> SensitivityAnalyzer.Metric.PROFIT_FACTOR;
                    case "Max Drawdown %" -> SensitivityAnalyzer.Metric.MAX_DRAWDOWN;
                    case "Win Rate %" -> SensitivityAnalyzer.Metric.WIN_RATE;
                    case "Calmar Ratio" -> SensitivityAnalyzer.Metric.CALMAR_RATIO;
                    case "Expectancy" -> SensitivityAnalyzer.Metric.EXPECTANCY;
                    default -> SensitivityAnalyzer.Metric.SHARPE_RATIO;
                };

                // Create analyzer with 10x10 grid
                SensitivityAnalyzer analyzer = new SensitivityAnalyzer(lastConfig, 10);

                // Run 2D analysis
                SensitivityAnalyzer.HeatmapResult result = analyzer.analyze2D(
                        lastStrategy, lastData, param1, param2, metric
                );

                Platform.runLater(() -> {
                    // Update heatmap chart
                    heatmapChart.setData(result);

                    // Update result text
                    StringBuilder sb = new StringBuilder();
                    sb.append("SENSITIVITY ANALYSIS RESULTS\n");
                    sb.append("============================\n\n");
                    sb.append(String.format("Parameters: %s vs %s\n", param1, param2));
                    sb.append(String.format("Metric: %s\n\n", metricName));
                    sb.append(String.format("OPTIMAL VALUES:\n"));
                    sb.append(String.format("  %s = %.4f\n", param1, result.getOptimalParam1()));
                    sb.append(String.format("  %s = %.4f\n", param2, result.getOptimalParam2()));
                    sb.append(String.format("  Best %s = %.4f\n\n", metricName, result.optimalValue()));

                    SensitivityAnalyzer.PlateauAnalysis plateau = result.plateau();
                    sb.append("ROBUSTNESS ANALYSIS:\n");
                    sb.append(String.format("  Plateau Size: %.1f%% of parameter space\n", plateau.plateauPercent()));
                    sb.append(String.format("  Parameter Sensitivity: %.2f\n", plateau.sensitivity()));
                    sb.append(String.format("  Robustness Rating: %s\n\n", plateau.robustness()));

                    if (plateau.plateauPercent() > 30) {
                        sb.append("ASSESSMENT: LOW OVERFITTING RISK\n");
                        sb.append("Large plateau indicates stable, robust parameter region.");
                    } else if (plateau.plateauPercent() > 15) {
                        sb.append("ASSESSMENT: MODERATE OVERFITTING RISK\n");
                        sb.append("Medium plateau - parameters moderately sensitive.");
                    } else {
                        sb.append("ASSESSMENT: HIGH OVERFITTING RISK\n");
                        sb.append("Small plateau - performance highly sensitive to parameters.\n");
                        sb.append("Consider widening parameter ranges or simplifying strategy.");
                    }

                    heatmapResultText.setText(sb.toString());
                    runHeatmapButton.setDisable(false);
                });
            } catch (Exception e) {
                Platform.runLater(() -> {
                    heatmapResultText.setText("ERROR running sensitivity analysis: " + e.getMessage());
                    runHeatmapButton.setDisable(false);
                });
            }
        });
    }

    private TableView<OosRow> createOosTable() {
        TableView<OosRow> table = new TableView<>();

        TableColumn<OosRow, String> metricCol = new TableColumn<>("Metric");
        metricCol.setCellValueFactory(data -> data.getValue().metricProperty());
        metricCol.setPrefWidth(150);

        TableColumn<OosRow, String> isCol = new TableColumn<>("In-Sample");
        isCol.setCellValueFactory(data -> data.getValue().inSampleProperty());
        isCol.setPrefWidth(120);

        TableColumn<OosRow, String> oosCol = new TableColumn<>("Out-of-Sample");
        oosCol.setCellValueFactory(data -> data.getValue().outOfSampleProperty());
        oosCol.setPrefWidth(120);

        TableColumn<OosRow, String> ratioCol = new TableColumn<>("OOS/IS Ratio");
        ratioCol.setCellValueFactory(data -> data.getValue().ratioProperty());
        ratioCol.setPrefWidth(100);
        ratioCol.setCellFactory(col -> new TableCell<>() {
            @Override
            protected void updateItem(String item, boolean empty) {
                super.updateItem(item, empty);
                if (empty || item == null) {
                    setText(null);
                    setStyle("");
                } else {
                    setText(item);
                    try {
                        double ratio = Double.parseDouble(item.replace("%", ""));
                        if (ratio >= 70) setStyle("-fx-text-fill: #00cc00;");
                        else if (ratio >= 50) setStyle("-fx-text-fill: #cccc00;");
                        else setStyle("-fx-text-fill: #cc0000;");
                    } catch (NumberFormatException e) {
                        setStyle("");
                    }
                }
            }
        });

        table.getColumns().addAll(metricCol, isCol, oosCol, ratioCol);
        table.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);

        return table;
    }

    private void runOutOfSampleTest() {
        if (lastStrategy == null || lastData == null || lastConfig == null) {
            oosResultText.setText("ERROR: No strategy or data available.\nRun a backtest first.");
            return;
        }

        runOosTestButton.setDisable(true);
        oosResultText.setText("Running Out-of-Sample test... please wait.");
        oosTable.getItems().clear();
        oosEquityChart.getData().clear();

        double oosPercent = oosSlider.getValue() / 100.0;

        CompletableFuture.runAsync(() -> {
            try {
                // Split data into In-Sample and Out-of-Sample portions
                int totalBars = lastData.size();
                int oosStart = (int) (totalBars * (1.0 - oosPercent));

                TimeSeries inSampleData = lastData.slice(0, oosStart);
                TimeSeries outOfSampleData = lastData.slice(oosStart, totalBars);

                // Create fresh strategy instances for each test
                String strategyName = lastStrategy.getName();
                BaseStrategy isStrategy = StrategyRegistry.createStrategy(strategyName, lastStrategy.getParameterValues());
                BaseStrategy oosStrategy = StrategyRegistry.createStrategy(strategyName, lastStrategy.getParameterValues());

                // Run backtests on both portions
                SimpleBacktestEngine engine = new SimpleBacktestEngine(lastConfig);

                BacktestResult isResult = engine.run(isStrategy, inSampleData);
                BacktestResult oosResult = engine.run(oosStrategy, outOfSampleData);

                // Calculate statistics
                StatisticsCalculator calculator = new StatisticsCalculator();
                BacktestStatistics isStats = calculator.calculate(isResult);
                BacktestStatistics oosStats = calculator.calculate(oosResult);

                Platform.runLater(() -> {
                    updateOosResults(isResult, oosResult, isStats, oosStats, oosPercent);
                    runOosTestButton.setDisable(false);
                });
            } catch (Exception e) {
                Platform.runLater(() -> {
                    oosResultText.setText("ERROR running OOS test: " + e.getMessage() + "\n\n" +
                            "Stack trace: " + e.toString());
                    runOosTestButton.setDisable(false);
                });
            }
        });
    }

    private void updateOosResults(BacktestResult isResult, BacktestResult oosResult,
                                   BacktestStatistics isStats, BacktestStatistics oosStats,
                                   double oosPercent) {
        // Update equity chart
        oosEquityChart.getData().clear();

        // In-Sample equity curve
        XYChart.Series<Number, Number> isSeries = new XYChart.Series<>();
        isSeries.setName("In-Sample");
        List<Portfolio.EquityPoint> isHistory = isResult.getEquityHistory();
        int isStep = Math.max(1, isHistory.size() / 300);
        for (int i = 0; i < isHistory.size(); i += isStep) {
            isSeries.getData().add(new XYChart.Data<>(i, isHistory.get(i).equity()));
        }

        // Out-of-Sample equity curve (offset to show after IS)
        XYChart.Series<Number, Number> oosSeries = new XYChart.Series<>();
        oosSeries.setName("Out-of-Sample");
        List<Portfolio.EquityPoint> oosHistory = oosResult.getEquityHistory();
        int oosStep = Math.max(1, oosHistory.size() / 300);
        int offset = isHistory.size();
        for (int i = 0; i < oosHistory.size(); i += oosStep) {
            oosSeries.getData().add(new XYChart.Data<>(offset + i, oosHistory.get(i).equity()));
        }

        oosEquityChart.getData().addAll(isSeries, oosSeries);

        // Apply consistent colors - In-Sample=blue, Out-of-Sample=green
        Platform.runLater(() -> {
            if (isSeries.getNode() != null) {
                isSeries.getNode().setStyle("-fx-stroke: #2196F3; -fx-stroke-width: 2;");
            }
            if (oosSeries.getNode() != null) {
                oosSeries.getNode().setStyle("-fx-stroke: #4CAF50; -fx-stroke-width: 2;");
            }
            styleChartLegend(oosEquityChart, "#2196F3", "#4CAF50");
        });

        // Update table
        oosTable.getItems().clear();

        // Calculate ratios (handle edge cases)
        double returnRatio = isStats.netReturnPercent() != 0 ?
                (oosStats.netReturnPercent() / isStats.netReturnPercent()) * 100 : 0;
        double sharpeRatio = isStats.sharpeRatio() != 0 && !Double.isNaN(isStats.sharpeRatio()) ?
                (oosStats.sharpeRatio() / isStats.sharpeRatio()) * 100 : 0;
        double winRateRatio = isStats.winRate() != 0 ?
                (oosStats.winRate() / isStats.winRate()) * 100 : 0;
        double profitFactorRatio = isStats.profitFactor() != 0 && !Double.isInfinite(isStats.profitFactor()) ?
                (oosStats.profitFactor() / isStats.profitFactor()) * 100 : 0;

        oosTable.getItems().addAll(
                new OosRow("Net Return", formatPercent(isStats.netReturnPercent()),
                        formatPercent(oosStats.netReturnPercent()), formatPercent(returnRatio)),
                new OosRow("Sharpe Ratio", formatNumber(isStats.sharpeRatio()),
                        formatNumber(oosStats.sharpeRatio()), formatPercent(sharpeRatio)),
                new OosRow("Win Rate", formatPercent(isStats.winRate()),
                        formatPercent(oosStats.winRate()), formatPercent(winRateRatio)),
                new OosRow("Profit Factor", formatNumber(isStats.profitFactor()),
                        formatNumber(oosStats.profitFactor()), formatPercent(profitFactorRatio)),
                new OosRow("Max Drawdown", formatPercent(isStats.maxDrawdownPercent()),
                        formatPercent(oosStats.maxDrawdownPercent()), "N/A"),
                new OosRow("Total Trades", String.valueOf(isStats.totalTrades()),
                        String.valueOf(oosStats.totalTrades()), "N/A"),
                new OosRow("Avg Trade", formatCurrency(isStats.avgTrade()),
                        formatCurrency(oosStats.avgTrade()), "N/A")
        );

        // Update text summary
        StringBuilder sb = new StringBuilder();
        sb.append("OUT-OF-SAMPLE TEST RESULTS\n");
        sb.append("==========================\n\n");
        sb.append(String.format("Data Split: %.0f%% In-Sample / %.0f%% Out-of-Sample\n",
                (1 - oosPercent) * 100, oosPercent * 100));
        sb.append(String.format("In-Sample Bars: %d | Out-of-Sample Bars: %d\n\n",
                isResult.getTotalBars(), oosResult.getTotalBars()));

        sb.append("PERFORMANCE COMPARISON:\n");
        sb.append(String.format("  Return:       IS=%.2f%% | OOS=%.2f%% | Ratio=%.1f%%\n",
                isStats.netReturnPercent(), oosStats.netReturnPercent(), returnRatio));
        sb.append(String.format("  Sharpe:       IS=%.2f  | OOS=%.2f  | Ratio=%.1f%%\n",
                isStats.sharpeRatio(), oosStats.sharpeRatio(), sharpeRatio));
        sb.append(String.format("  Win Rate:     IS=%.1f%% | OOS=%.1f%% | Ratio=%.1f%%\n",
                isStats.winRate(), oosStats.winRate(), winRateRatio));
        sb.append("\n");

        // Determine overfitting risk
        double avgRatio = (returnRatio + sharpeRatio + winRateRatio) / 3.0;
        String assessment;
        if (avgRatio >= 70 || (oosStats.netReturnPercent() > 0 && isStats.netReturnPercent() > 0)) {
            if (returnRatio >= 70) {
                assessment = "LOW OVERFITTING RISK - Strategy performs well out-of-sample.";
            } else if (returnRatio >= 50) {
                assessment = "MODERATE OVERFITTING RISK - Some performance degradation OOS.";
            } else {
                assessment = "HIGH OVERFITTING RISK - Significant performance drop OOS.";
            }
        } else if (oosStats.netReturnPercent() <= 0 && isStats.netReturnPercent() > 0) {
            assessment = "HIGH OVERFITTING RISK - Strategy loses money out-of-sample!";
        } else {
            assessment = "INCONCLUSIVE - Both periods show losses. Review strategy logic.";
        }

        sb.append("ASSESSMENT: ").append(assessment);

        oosResultText.setText(sb.toString());
    }

    private String formatCurrency(double value) {
        return String.format("$%,.2f", value);
    }

    private String formatPercent(double value) {
        return String.format("%.2f%%", value);
    }

    private String formatNumber(double value) {
        if (Double.isInfinite(value)) return "∞";
        if (Double.isNaN(value)) return "N/A";
        return String.format("%.2f", value);
    }

    /**
     * Table row for statistics.
     */
    public static class StatRow {
        private final javafx.beans.property.SimpleStringProperty category;
        private final javafx.beans.property.SimpleStringProperty metric;
        private final javafx.beans.property.SimpleStringProperty value;

        public StatRow(String category, String metric, String value) {
            this.category = new javafx.beans.property.SimpleStringProperty(category);
            this.metric = new javafx.beans.property.SimpleStringProperty(metric);
            this.value = new javafx.beans.property.SimpleStringProperty(value);
        }

        public javafx.beans.property.StringProperty categoryProperty() { return category; }
        public javafx.beans.property.StringProperty metricProperty() { return metric; }
        public javafx.beans.property.StringProperty valueProperty() { return value; }
    }

    /**
     * Table row for stress test results.
     */
    public static class StressRow {
        private final javafx.beans.property.SimpleStringProperty scenario;
        private final javafx.beans.property.SimpleStringProperty returnValue;
        private final javafx.beans.property.SimpleStringProperty sharpe;
        private final javafx.beans.property.SimpleStringProperty maxDD;
        private final javafx.beans.property.SimpleStringProperty status;

        public StressRow(String scenario, String returnValue, String sharpe, String maxDD, String status) {
            this.scenario = new javafx.beans.property.SimpleStringProperty(scenario);
            this.returnValue = new javafx.beans.property.SimpleStringProperty(returnValue);
            this.sharpe = new javafx.beans.property.SimpleStringProperty(sharpe);
            this.maxDD = new javafx.beans.property.SimpleStringProperty(maxDD);
            this.status = new javafx.beans.property.SimpleStringProperty(status);
        }

        public javafx.beans.property.StringProperty scenarioProperty() { return scenario; }
        public javafx.beans.property.StringProperty returnProperty() { return returnValue; }
        public javafx.beans.property.StringProperty sharpeProperty() { return sharpe; }
        public javafx.beans.property.StringProperty maxDDProperty() { return maxDD; }
        public javafx.beans.property.StringProperty statusProperty() { return status; }
    }

    /**
     * Table row for Out-of-Sample test results.
     */
    public static class OosRow {
        private final javafx.beans.property.SimpleStringProperty metric;
        private final javafx.beans.property.SimpleStringProperty inSample;
        private final javafx.beans.property.SimpleStringProperty outOfSample;
        private final javafx.beans.property.SimpleStringProperty ratio;

        public OosRow(String metric, String inSample, String outOfSample, String ratio) {
            this.metric = new javafx.beans.property.SimpleStringProperty(metric);
            this.inSample = new javafx.beans.property.SimpleStringProperty(inSample);
            this.outOfSample = new javafx.beans.property.SimpleStringProperty(outOfSample);
            this.ratio = new javafx.beans.property.SimpleStringProperty(ratio);
        }

        public javafx.beans.property.StringProperty metricProperty() { return metric; }
        public javafx.beans.property.StringProperty inSampleProperty() { return inSample; }
        public javafx.beans.property.StringProperty outOfSampleProperty() { return outOfSample; }
        public javafx.beans.property.StringProperty ratioProperty() { return ratio; }
    }
}
